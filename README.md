### Рассуждения в ходе решения

Загвоздка решения состояла в том, как хранить данные. У меня было несколько идей:
- хранить пары, где ключом является UserID, а занчением - Time Stamp запроса. Это решение не подходит при использовании Redis, тк он не моддеживает храниение записей с одинаковыми ключами (в отличие от MongoDB. Но решила не брать Монгу тк она намного медленнее Редиса)
- хранить пары, где ключом является UserID, а занчением - список Time Stamp запросов (этот вариант я выбрала для реализации)
- хранить пары, где ключом является UserID, а занчением - хеш-таблица, где ключ - это Time Stamp запроса, а значение - кол-во запросов в данную секунду. Это решение я решила отсечь, т.к. в Go мапа unordered, поэтому пришлось бы обходить всю мапу целиком, чтобы отсечь неактуальные Time Stamp'ы и параллельно считать counter кол-ва актуальных по времени запросов. Во ремя решения тестового заданияе мне показалось, что это не оптимально по сравнению с реализованным решением, т.к не хотелось пересчитывать каждый раз counter. Но анализируя сейчас (после сдачи решения) хочу отметить: Это решение оптимальнее по памяти и время подсчета кол-ва актуальных запросов зависит от времени в условии флуд-чекера, а удаление неактульных Time Stamp зависит от кол-ва секунд, в которые прилетали запросы. В условиях флуда это решение оптимальнее по времени и по памяти, чем реализованное. К тому же можно определить верхнюю границу занимаемой памяти O(m), где m - кол-во секунд в условии флуд-чекера. 

Решение реализовано с использованием RedisDB. Была выбрана эта БД, тк она быстрая и решение предполагало хранение данных в виде пар ключ-значение.

В ходе проделанной работы был реализован метод Check(). Метод основан на очереди типа FIFO. Суть метода: 
- добавляем в список Time Stamp запроса по UserID
- по UserID достаем из БД весь список запросов
- пробегаемся по запросам и ищем первое вхождение Time Stamp, который входит в проверяемый промежуток времени
- удаляем из массива все элементы, стоящие до него и перезаписываем в БД
- длину оставшегося списка проверяем на условие флуд-контроля

В итоге метод работает за O(n), где n - кол-во вызова метода Check().


### Запуск

```go run main.go```


